#!/usr/bin/env node

require('./tokens');

var NODES = {
  ROOT: 'root',
  NIL: 'nil',
  BOOLEAN: 'bool',
  NUMBER: 'number',
  STRING: 'string',
  SYMBOL: 'symbol',
  ARRAY: 'array',
  OBJECT: 'object',
  CALL: 'call',
  REF: 'REF',
  BLOCK: 'block'
};

var tokens;
var index;
var token;

function readList(ast, endCh) {
  while (true) {
    index = index + 1;
    token = tokens[index];
    if (!token) {
      throw new Error('unterminated list starting at ' + ast.token.from + '\nstart: ' +
        token.nodes.map(function(node) { return node.nodes ? '<list|object|call>' : node.value; }).join(' '));
    }
    if (token.type === 'operator' && token.value === endCh) {
        return;
    }
    readToken(ast, token);
  }
}

function readToken(ast, token) {
    if (token.type === 'name' && token.value === 'nil') {
      ast.nodes.push({type: NODES.NIL, token: token, value: undefined});
      return;
    }
    if (token.type === 'name' && token.value === 'true') {
      ast.nodes.push({type: NODES.BOOLEAN, token: token, value: true});
      return;
    }
    if (token.type === 'name' && token.value === 'false') {
      ast.nodes.push({type: NODES.BOOLEAN, token: token, value: false});
      return;
    }
    if (token.type === 'number') {
      ast.nodes.push({type: NODES.NUMBER, token: token, value: token.value});
      return;
    }
    if (token.type === 'string') {
      ast.nodes.push({type: NODES.STRING, token: token, value: token.value});
      return;
    }
    if (token.type === 'operator' && token.value === '[') {
      ast.nodes.push({type: NODES.ARRAY, token: token, nodes: []});
      readList(ast.nodes[ast.nodes.length-1], ']');
      return;
    }
    if (token.type === 'operator' && token.value === '{') {
      ast.nodes.push({type: NODES.OBJECT, token: token, nodes: []});
      readList(ast.nodes[ast.nodes.length-1], '}');
      return;
    }
    if (token.type === 'operator' && token.value === '(') {
      ast.nodes[ast.nodes.length-1] = {
        type: NODES.CALL,
        token: token,
        calee: ast.nodes[ast.nodes.length-1],
        nodes: []
      };
      readList(ast.nodes[ast.nodes.length-1], ')');
      return;
    }
    if (token.type === 'operator' && token.value === '.') {
      var refAst = {nodes: []};
      index = index + 1;
      token = tokens[index];

      // If next token is . too, it's not a ref but a symbol
      if (token.value === '.') {
        ast.nodes.push({type: NODES.SYMBOL, token: tokens[index-1], value: '..'});
        return;
      }

      readToken(refAst, token);
      ast.nodes[ast.nodes.length-1] = {
        type: NODES.REF,
        token: token,
        left: ast.nodes[ast.nodes.length-1],
        right: refAst.nodes[0]
      };
      return;
    }
    ast.nodes.push({type: NODES.SYMBOL, token: token, value: token.value});
    // throw new Error('unhandled token: ' + JSON.stringify(token));
}

function read(code) {
  var ast = {
    type: NODES.ROOT,
    nodes: []
  };

  tokens = code.tokens('=<>!+-*&|/%^', '=<>&|');
  index = -1;

  while (true) {
    index = index + 1;
    token = tokens[index];
    if (!token) {
      break;
    }

    readToken(ast, token);
  }

  return ast;
}

function escapeSymbol(symbol) {
  // special
  symbol = symbol.replace(/\./g, '_dot_');
  symbol = symbol.replace(/!/g, '_bang_');
  symbol = symbol.replace(/\?/g, '_q_');
  symbol = symbol.replace(/-/g, '_');

  // operators
  symbol = symbol.replace(/\+/g, 'sum');
  symbol = symbol.replace(/-/g, 'sub');
  symbol = symbol.replace(/\*/g, 'mult');
  symbol = symbol.replace(/\//g, 'div');
  symbol = symbol.replace(/%/g, 'mod');
  symbol = symbol.replace(/==/g, 'isEqual');
  symbol = symbol.replace(/!=/g, 'isNotEqual');
  symbol = symbol.replace(/<=/g, 'isLowerOrEqual');
  symbol = symbol.replace(/>=/g, 'isGreaterOrEqual');
  symbol = symbol.replace(/</g, 'isLower');
  symbol = symbol.replace(/>/g, 'isGreater');
  symbol = symbol.replace(/\|\|/g, 'or');
  symbol = symbol.replace(/&&/g, 'and');

  // reserved
  symbol = symbol.replace(/^export$/g, '_export');
  symbol = symbol.replace(/^import$/g, '_import');
  symbol = symbol.replace(/^in$/g, '_in');
  symbol = symbol.replace(/^instanceof$/g, '_instanceof');
  symbol = symbol.replace(/^new$/g, '_new');
  symbol = symbol.replace(/^throw$/g, '_throw');
  symbol = symbol.replace(/^try$/g, '_try');
  symbol = symbol.replace(/^typeof$/g, '_typeof');
  symbol = symbol.replace(/^void$/g, '_void');
  return symbol;
}

function writeNode(node) {
  if (node.type === NODES.ROOT) {
    return node.nodes.map(writeNode).join('\n');
  }
  if (node.type === NODES.ARRAY) {
    return '[' + node.nodes.map(writeNode).join(', ') + ']';
  }
  if (node.type === NODES.OBJECT) {
    if (node.nodes.length % 2 !== 0) {
      throw new Error('object literal contains an odd number of elements, need a value for each key' +
        '\ngiven: ' + prettyPrintNode(node));
    }
    var out = '';
    for (var i = 0; i < node.nodes.length; i++) {
      if (i % 2 === 0) {
        out = out + writeNode(node.nodes[i]) + ': ';
      } else {
        out = out + writeNode(node.nodes[i]);
        if (i !== node.nodes.length - 1) {
          out = out + ', ';
        }
      }
    }
    return '{' + out.trim() + '}';
  }
  if (node.type === NODES.CALL) {
    return writeNode(node.calee) + '(' + node.nodes.map(writeNode).join(', ') + ')';
  }
  if (node.type === NODES.REF) {
    // symbol to the right? use dot deref notation
    if (node.right.type === NODES.SYMBOL) {
      return writeNode(node.left) + '.' + writeNode(node.right);
    }
    return writeNode(node.left) + '[' + writeNode(node.right) + ']';
  }
  if (node.type === NODES.SYMBOL) {
    return escapeSymbol(node.value);
  }
  return node.value === undefined ? 'undefined' : JSON.stringify(node.value);
}

function write(ast) {
  return writeNode(ast);
}

function prettyPrint(ast) {
  function prettyPrintNode(node) {
    if (node.type === NODES.ROOT) {
      return node.nodes.map(prettyPrintNode).join('\n');
    }
    if (node.type === NODES.ARRAY) {
      return '[' + node.nodes.map(prettyPrintNode).join(' ') + ']';
    }
    if (node.type === NODES.OBJECT) {
      return '{' + node.nodes.map(prettyPrintNode).join(' ') + '}';
    }
    if (node.type === NODES.CALL) {
      return prettyPrintNode(node.calee) + '(' + node.nodes.map(prettyPrintNode).join(' ') + ')';
    }
    if (node.type === NODES.REF) {
      return prettyPrintNode(node.left) + '.' + prettyPrintNode(node.right);
    }
    if (node.type === NODES.SYMBOL) {
      return node.value;
    }
    return node.value === undefined ? 'undefined' : JSON.stringify(node.value);
  }
  return prettyPrintNode(ast);
}

function compile(code) {
  return write(read(code));
}

function indent(jsCode) {
  var out = '';
  var indentWidth = '';
  var inString = false;
  for (var i = 0; i < jsCode.length; i++) {
    if (jsCode[i] === '}' && !inString) {
      indentWidth = indentWidth.slice(0, -2);
      out += '\n' + indentWidth;
    }

    out += jsCode[i];
    if (jsCode[i] === '"' && (jsCode[i-1] !== '\\' || (jsCode[i-1] === '\\' &&jsCode[i-2] === '\\' ))) {
      inString = !inString;
    }

    if (jsCode[i] === '{' && !inString) {
      indentWidth += '  ';
      out += '\n' + indentWidth;
    }
    if (jsCode[i] === ';' && !inString) {
      if (jsCode[i + 1] !== '}') {
        out += '\n' + indentWidth;
      }
    }
  }
  return out;
}

// cli
if (process.stdin.isTTY) {
  console.log('eth needs a file in stdin to compile!');
  process.exit(1);
}

var chunks = [];
process.stdin.setEncoding('utf-8');
process.stdin.on('readable', function() {
  var chunk = process.stdin.read();
  if (chunk !== null) {
    chunks.push(chunk);
  }
});
process.stdin.on('end', function() {
    var body = chunks.join('');
    process.stdout.write(indent(compile(body)) + '\n');
});
